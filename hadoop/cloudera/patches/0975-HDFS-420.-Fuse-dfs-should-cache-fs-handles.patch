From 2348c8bfd82cbb3aa4685e7f8d85968c7cbe08b1 Mon Sep 17 00:00:00 2001
From: Eli Collins <eli@cloudera.com>
Date: Wed, 22 Jun 2011 10:30:47 -0700
Subject: [PATCH 0975/1020] HDFS-420. Fuse-dfs should cache fs handles.

Fuse-dfs should cache fs handles on a per-user basis. This significantly
increases performance (and has the side effect of fixing the current code
which leaks fs handles).

Reason: Improvement
Author: Brian Bockelman, Eli Collins
Ref: CDH-2786
---
 src/c++/libhdfs/hdfs.c                         |    2 +-
 src/contrib/fuse-dfs/build.xml                 |   13 +++-
 src/contrib/fuse-dfs/configure.ac              |    3 +
 src/contrib/fuse-dfs/src/fuse_connect.c        |  107 +++++++++++++++++++----
 src/contrib/fuse-dfs/src/fuse_connect.h        |   10 +--
 src/contrib/fuse-dfs/src/fuse_context_handle.h |    1 -
 src/contrib/fuse-dfs/src/fuse_dfs.c            |   78 ++++++++----------
 src/contrib/fuse-dfs/src/fuse_dfs.h            |    5 -
 src/contrib/fuse-dfs/src/fuse_dfs_wrapper.sh   |    2 +-
 src/contrib/fuse-dfs/src/fuse_impls_access.c   |   18 +----
 src/contrib/fuse-dfs/src/fuse_impls_chmod.c    |   25 +++---
 src/contrib/fuse-dfs/src/fuse_impls_chown.c    |   49 ++++++-----
 src/contrib/fuse-dfs/src/fuse_impls_getattr.c  |   26 +++---
 src/contrib/fuse-dfs/src/fuse_impls_mkdir.c    |   22 +++--
 src/contrib/fuse-dfs/src/fuse_impls_open.c     |   19 ++---
 src/contrib/fuse-dfs/src/fuse_impls_readdir.c  |   29 +++----
 src/contrib/fuse-dfs/src/fuse_impls_release.c  |    6 ++
 src/contrib/fuse-dfs/src/fuse_impls_rename.c   |   16 +++-
 src/contrib/fuse-dfs/src/fuse_impls_rmdir.c    |   25 ++++--
 src/contrib/fuse-dfs/src/fuse_impls_statfs.c   |   32 +------
 src/contrib/fuse-dfs/src/fuse_impls_truncate.c |   21 +++--
 src/contrib/fuse-dfs/src/fuse_impls_unlink.c   |   20 +++--
 src/contrib/fuse-dfs/src/fuse_impls_utimens.c  |   28 ++++---
 src/contrib/fuse-dfs/src/fuse_init.c           |   31 ++-----
 src/contrib/fuse-dfs/src/fuse_options.c        |   11 +--
 src/contrib/fuse-dfs/src/fuse_stat_struct.c    |   19 +----
 src/contrib/fuse-dfs/src/fuse_users.c          |   14 +---
 27 files changed, 330 insertions(+), 302 deletions(-)

diff --git a/src/c++/libhdfs/hdfs.c b/src/c++/libhdfs/hdfs.c
index 53f94bb..36a7c87 100644
--- a/src/c++/libhdfs/hdfs.c
+++ b/src/c++/libhdfs/hdfs.c
@@ -259,7 +259,7 @@ hdfsFS hdfsConnectAsUser(const char* host, tPort port, const char *user)
       sprintf(cURI, "hdfs://%s:%d", host, (int)(port));
       if (cURI == NULL) {
         fprintf (stderr, "Couldn't allocate an object of size %d",
-                 strlen(host) + 16);
+                 (int)(strlen(host) + 16));
         errno = EINTERNAL;			
         goto done;	
       }
diff --git a/src/contrib/fuse-dfs/build.xml b/src/contrib/fuse-dfs/build.xml
index 4e9b1c8..fc489ae 100644
--- a/src/contrib/fuse-dfs/build.xml
+++ b/src/contrib/fuse-dfs/build.xml
@@ -60,7 +60,18 @@
       <env key="HADOOP_HOME" value="${hadoop.root}"/>
       <env key="PACKAGE_VERSION" value="0.1.0"/>
       <env key="BUILD_PLATFORM" value="${build.platform}" />
-      <env key="PERMS" value="${perms}"/>
+    </exec>
+
+    <mkdir dir="${build.dir}"/>
+    <mkdir dir="${build.dir}/test"/>
+
+    <!-- Use exec since the copy task doesn't preserve attrs -->
+    <exec executable="cp" failonerror="true">
+      <arg line="${hadoop.root}/src/contrib/fuse-dfs/src/fuse_dfs ${build.dir}"/>
+    </exec>
+
+    <exec executable="cp" failonerror="true">
+      <arg line="${hadoop.root}/src/contrib/fuse-dfs/src/fuse_dfs_wrapper.sh ${build.dir}"/>
     </exec>
     <mkdir dir="${build.dir}"/>
     <mkdir dir="${build.dir}/test"/>
diff --git a/src/contrib/fuse-dfs/configure.ac b/src/contrib/fuse-dfs/configure.ac
index 26c6b0f..60a6ca4 100644
--- a/src/contrib/fuse-dfs/configure.ac
+++ b/src/contrib/fuse-dfs/configure.ac
@@ -40,6 +40,9 @@ AC_PREFIX_DEFAULT([`pwd`])
  DEFS=""
 AC_SUBST([DEFS])
 
+# Need GNU source for multiple hashtables from glibc
+AC_GNU_SOURCE
+
 AC_FUNC_GETGROUPS
 AC_TYPE_GETGROUPS
 
diff --git a/src/contrib/fuse-dfs/src/fuse_connect.c b/src/contrib/fuse-dfs/src/fuse_connect.c
index 4ac4886..f942067 100644
--- a/src/contrib/fuse-dfs/src/fuse_connect.c
+++ b/src/contrib/fuse-dfs/src/fuse_connect.c
@@ -17,37 +17,106 @@
  */
 
 #include "hdfs.h"
-
 #include "fuse_dfs.h"
 #include "fuse_connect.h"
 #include "fuse_users.h" 
 
+#include <search.h>
 
-#if PERMS
+#define MAX_ELEMENTS (16 * 1024)
+static struct hsearch_data *fsTable = NULL;
+static pthread_mutex_t tableMutex = PTHREAD_MUTEX_INITIALIZER;
 
-/**
- * Connects to the NN as the current user/group according to FUSE
- *
+/*
+ * Allocate a hash table for fs handles. Returns 0 on success,
+ * -1 on failure.
  */
-hdfsFS doConnectAsUser(const char *hostname, int port) {
-  uid_t uid = fuse_get_context()->uid;
+int allocFsTable(void) {
+  assert(NULL == fsTable);
+  fsTable = calloc(1, sizeof(struct hsearch_data));
+  if (0 == hcreate_r(MAX_ELEMENTS, fsTable)) {
+    ERROR("Unable to initialize connection table");
+    return -1;
+  }
+  return 0;
+}
 
-  char *user = getUsername(uid);
-  if (NULL == user)
+/*
+ * Find a fs handle for the given key. Returns a fs handle, 
+ * or NULL if there is no fs for the given key.
+ */
+static hdfsFS findFs(char *key) {
+  ENTRY entry;
+  ENTRY *entryP = NULL;
+  entry.key = key;
+  if (0 == hsearch_r(entry, FIND, &entryP, fsTable)) {
     return NULL;
-  int numgroups = 0;
-  char **groups = getGroups(uid, &numgroups);
-  hdfsFS fs = hdfsConnectAsUser(hostname, port, user);
-  freeGroups(groups, numgroups);
-  if (user) 
-    free(user);
-  return fs;
+  }
+  assert(NULL != entryP->data);
+  return (hdfsFS)entryP->data;
 }
 
-#else
+/*
+ * Insert the given fs handle into the table.
+ * Returns 0 on success, -1 on failure.
+ */
+static int insertFs(char *key, hdfsFS fs) {
+  ENTRY entry;
+  ENTRY *entryP = NULL;
+  assert(NULL != fs);
+  entry.key = strdup(key);
+  if (entry.key == NULL) {
+    return -1;
+  }
+  entry.data = (void*)fs;
+  if (0 == hsearch_r(entry, ENTER, &entryP, fsTable)) {
+    return -1;
+  }
+  return 0;
+}
 
+/*
+ * Connect to the NN as the current user/group.
+ * Returns a fs handle on success, or NULL on failure.
+ */
 hdfsFS doConnectAsUser(const char *hostname, int port) {
-  return hdfsConnect(hostname, port);
+  uid_t uid = fuse_get_context()->uid;
+  char *user = getUsername(uid);
+  int ret;
+  hdfsFS fs = NULL;
+  if (NULL == user) {
+    goto done;
+  }
+
+  ret = pthread_mutex_lock(&tableMutex);
+  assert(0 == ret);
+
+  fs = findFs(user);
+  if (NULL == fs) {
+    fs = hdfsConnectAsUserNewInstance(hostname, port, user);
+    if (NULL == fs) {
+      ERROR("Unable to create fs for user %s", user);
+      goto done;
+    }
+    if (-1 == insertFs(user, fs)) {
+      ERROR("Unable to cache fs for user %s", user);
+    }
+  }
+
+done:
+  ret = pthread_mutex_unlock(&tableMutex);
+  assert(0 == ret);
+  if (user) {
+    free(user);
+  }
+  return fs;
 }
 
-#endif
+/*
+ * We currently cache a fs handle per-user in this module rather
+ * than use the FileSystem cache in the java client. Therefore
+ * we do not disconnect the fs handle here.
+ */
+int doDisconnect(hdfsFS fs) {
+  return 0;
+}
diff --git a/src/contrib/fuse-dfs/src/fuse_connect.h b/src/contrib/fuse-dfs/src/fuse_connect.h
index e36685b..23450a5 100644
--- a/src/contrib/fuse-dfs/src/fuse_connect.h
+++ b/src/contrib/fuse-dfs/src/fuse_connect.h
@@ -21,12 +21,8 @@
 
 #include "fuse_dfs.h"
 
-/**
- * Connects to the NN as the current user/group according to FUSE.
- * Uses the fuse context to get the user name and groups.
- * (if hadoop pre 0.19, will ignore user and group).
- */
-
-hdfsFS doConnectAsUser(const char *hostname, int port) ;
+hdfsFS doConnectAsUser(const char *hostname, int port);
+int doDisconnect(hdfsFS fs);
+int allocFsTable(void);
 
 #endif
diff --git a/src/contrib/fuse-dfs/src/fuse_context_handle.h b/src/contrib/fuse-dfs/src/fuse_context_handle.h
index a67855d..3e47a1e 100644
--- a/src/contrib/fuse-dfs/src/fuse_context_handle.h
+++ b/src/contrib/fuse-dfs/src/fuse_context_handle.h
@@ -33,7 +33,6 @@ typedef struct dfs_context_struct {
   int debug;
   char *nn_hostname;
   int nn_port;
-  hdfsFS fs;
   int read_only;
   int usetrash;
   int direct_io;
diff --git a/src/contrib/fuse-dfs/src/fuse_dfs.c b/src/contrib/fuse-dfs/src/fuse_dfs.c
index 6d40634..3b19f45 100644
--- a/src/contrib/fuse-dfs/src/fuse_dfs.c
+++ b/src/contrib/fuse-dfs/src/fuse_dfs.c
@@ -20,7 +20,7 @@
 #include "fuse_options.h"
 #include "fuse_impls.h"
 #include "fuse_init.h"
-
+#include "fuse_connect.h"
 
 int is_protected(const char *path) {
 
@@ -38,55 +38,49 @@ int is_protected(const char *path) {
 }
 
 static struct fuse_operations dfs_oper = {
-  .getattr	= dfs_getattr,
-  .access	= dfs_access,
-  .readdir	= dfs_readdir,
-  .destroy       = dfs_destroy,
-  .init         = dfs_init,
-  .open	        = dfs_open,
-  .read	        = dfs_read,
-  .symlink	= dfs_symlink,
-  .statfs	= dfs_statfs,
-  .mkdir	= dfs_mkdir,
-  .rmdir	= dfs_rmdir,
-  .rename	= dfs_rename,
-  .unlink       = dfs_unlink,
-  .release      = dfs_release,
-  .create       = dfs_create,
-  .write	= dfs_write,
-  .flush        = dfs_flush,
-  .mknod        = dfs_mknod,
-  .utimens      = dfs_utimens,
-  .chmod	= dfs_chmod,
-  .chown	= dfs_chown,
-  .truncate	= dfs_truncate,
+  .getattr  = dfs_getattr,
+  .access   = dfs_access,
+  .readdir  = dfs_readdir,
+  .destroy  = dfs_destroy,
+  .init     = dfs_init,
+  .open     = dfs_open,
+  .read     = dfs_read,
+  .symlink  = dfs_symlink,
+  .statfs   = dfs_statfs,
+  .mkdir    = dfs_mkdir,
+  .rmdir    = dfs_rmdir,
+  .rename   = dfs_rename,
+  .unlink   = dfs_unlink,
+  .release  = dfs_release,
+  .create   = dfs_create,
+  .write    = dfs_write,
+  .flush    = dfs_flush,
+  .mknod    = dfs_mknod,
+  .utimens  = dfs_utimens,
+  .chmod    = dfs_chmod,
+  .chown    = dfs_chown,
+  .truncate = dfs_truncate,
 };
 
-
 int main(int argc, char *argv[])
 {
-
   umask(0);
 
   extern const char *program;  
   program = argv[0];
   struct fuse_args args = FUSE_ARGS_INIT(argc, argv);
 
-  /* clear structure that holds our options */
   memset(&options, 0, sizeof(struct options));
 
-  // some defaults
   options.rdbuffer_size = 10*1024*1024; 
   options.attribute_timeout = 60; 
   options.entry_timeout = 60;
 
-  if (fuse_opt_parse(&args, &options, dfs_opts, dfs_options) == -1)
-    /** error parsing options */
+  if (-1 == fuse_opt_parse(&args, &options, dfs_opts, dfs_options)) {
     return -1;
+  }
 
-
-  // Some fuse options we set
-  if (! options.private) {
+  if (!options.private) {
     fuse_opt_add_arg(&args, "-oallow_other");
   }
 
@@ -109,28 +103,24 @@ int main(int argc, char *argv[])
     exit(0);
   }
 
-
-  // 
-  // Check we can connect to hdfs
-  // 
+  // Check connection as root
   if (options.initchecks == 1) {
-    hdfsFS temp;
-    if ((temp = hdfsConnect(options.server, options.port)) == NULL) {
+    hdfsFS tempFS = hdfsConnectAsUser(options.server, options.port, "root");
+    if (NULL == tempFS) {
       const char *cp = getenv("CLASSPATH");
       const char *ld = getenv("LD_LIBRARY_PATH");
       ERROR("FATAL: misconfiguration - cannot connect to HDFS");
       ERROR("LD_LIBRARY_PATH=%s",ld == NULL ? "NULL" : ld);
       ERROR("CLASSPATH=%s",cp == NULL ? "NULL" : cp);
-      exit(0);
+      exit(1);
+    }
+    if (doDisconnect(tempFS)) {
+      ERROR("FATAL: unable to disconnect from test filesystem.");
+      exit(1);
     }
   }
 
   int ret = fuse_main(args.argc, args.argv, &dfs_oper, NULL);
-
-  if (ret) printf("\n");
-
-  /** free arguments */
   fuse_opt_free_args(&args);
-
   return ret;
 }
diff --git a/src/contrib/fuse-dfs/src/fuse_dfs.h b/src/contrib/fuse-dfs/src/fuse_dfs.h
index ad20b9a..56ed9cb 100644
--- a/src/contrib/fuse-dfs/src/fuse_dfs.h
+++ b/src/contrib/fuse-dfs/src/fuse_dfs.h
@@ -35,11 +35,6 @@
 #include <config.h>
 #endif
 
-#ifdef linux
-/* For pread()/pwrite() */
-#define _XOPEN_SOURCE 500
-#endif
-
 #ifdef HAVE_SETXATTR
 #include <sys/xattr.h>
 #endif
diff --git a/src/contrib/fuse-dfs/src/fuse_dfs_wrapper.sh b/src/contrib/fuse-dfs/src/fuse_dfs_wrapper.sh
index 0169ec8..9a45744 100755
--- a/src/contrib/fuse-dfs/src/fuse_dfs_wrapper.sh
+++ b/src/contrib/fuse-dfs/src/fuse_dfs_wrapper.sh
@@ -28,7 +28,7 @@ export  JAVA_HOME=/usr/local/java
 fi
 
 if [ "$LD_LIBRARY_PATH" = "" ]; then
-export LD_LIBRARY_PATH=$JAVA_HOME/jre/lib/$OS_ARCH/server:/usr/local/share/hdfs/libhdfs/:/usr/local/lib
+export LD_LIBRARY_PATH=$JAVA_HOME/jre/lib/$OS_ARCH/server:/usr/local/lib
 fi
 
 # If dev build set paths accordingly
diff --git a/src/contrib/fuse-dfs/src/fuse_impls_access.c b/src/contrib/fuse-dfs/src/fuse_impls_access.c
index c804011..033a1c3 100644
--- a/src/contrib/fuse-dfs/src/fuse_impls_access.c
+++ b/src/contrib/fuse-dfs/src/fuse_impls_access.c
@@ -23,21 +23,7 @@
 int dfs_access(const char *path, int mask)
 {
   TRACE1("access", path)
-  // bugbug - I think we need the FileSystemAPI/libhdfs to expose this!
-  // retrieve dfs specific data
-  dfs_context *dfs = (dfs_context*)fuse_get_context()->private_data;
-
-  // check params and the context var
-  assert(dfs);
-  assert(path);
-
-  hdfsFS userFS;
-  if ((userFS = doConnectAsUser(dfs->nn_hostname,dfs->nn_port)) == NULL) {
-    ERROR("Could not connect to HDFS");
-    return -EIO;
-  }
-  //  return hdfsAccess(userFS, path, mask);
+  assert(path != NULL);
+  // TODO: HDFS-428
   return 0;
 }
-
-
diff --git a/src/contrib/fuse-dfs/src/fuse_impls_chmod.c b/src/contrib/fuse-dfs/src/fuse_impls_chmod.c
index f397c03..dbf39a7 100644
--- a/src/contrib/fuse-dfs/src/fuse_impls_chmod.c
+++ b/src/contrib/fuse-dfs/src/fuse_impls_chmod.c
@@ -24,27 +24,30 @@
 int dfs_chmod(const char *path, mode_t mode)
 {
   TRACE1("chmod", path)
-
-#if PERMS
-  // retrieve dfs specific data
+  int ret = 0;
   dfs_context *dfs = (dfs_context*)fuse_get_context()->private_data;
 
-  // check params and the context var
   assert(path);
   assert(dfs);
   assert('/' == *path);
 
-  hdfsFS userFS;
-  // if not connected, try to connect and fail out if we can't.
-  if ((userFS = doConnectAsUser(dfs->nn_hostname,dfs->nn_port))== NULL) {
+  hdfsFS userFS = doConnectAsUser(dfs->nn_hostname, dfs->nn_port);
+  if (userFS == NULL) {
     ERROR("Could not connect to HDFS");
-    return -EIO;
+    ret = -EIO;
+    goto cleanup;
   }
 
   if (hdfsChmod(userFS, path, (short)mode)) {
     ERROR("Could not chmod %s to %d", path, (int)mode);
-    return -EIO;
+    ret = (errno > 0) ? -errno : -EIO;
+    goto cleanup;
+  }
+
+cleanup:
+  if (doDisconnect(userFS)) {
+    ret = -EIO;
   }
-#endif
-  return 0;
+
+  return ret;
 }
diff --git a/src/contrib/fuse-dfs/src/fuse_impls_chown.c b/src/contrib/fuse-dfs/src/fuse_impls_chown.c
index 10cdd31..53e48b4 100644
--- a/src/contrib/fuse-dfs/src/fuse_impls_chown.c
+++ b/src/contrib/fuse-dfs/src/fuse_impls_chown.c
@@ -26,10 +26,9 @@
   TRACE1("chown", path)
 
   int ret = 0;
-
-#if PERMS
   char *user = NULL;
   char *group = NULL;
+  hdfsFS userFS = NULL;
 
   // retrieve dfs specific data
   dfs_context *dfs = (dfs_context*)fuse_get_context()->private_data;
@@ -43,36 +42,40 @@
   if (NULL == user) {
     ERROR("Could not lookup the user id string %d",(int)uid); 
     ret = -EIO;
+    goto cleanup;
   }
 
-  if (0 == ret) {
-    group = getGroup(gid);
-    if (group == NULL) {
-      ERROR("Could not lookup the group id string %d",(int)gid);
-      ret = -EIO;
-    } 
+  group = getGroup(gid);
+  if (group == NULL) {
+    ERROR("Could not lookup the group id string %d",(int)gid);
+    ret = -EIO;
+    goto cleanup;
+  } 
+
+  userFS = doConnectAsUser(dfs->nn_hostname, dfs->nn_port);
+  if (userFS == NULL) {
+    ERROR("Could not connect to HDFS");
+    ret = -EIO;
+    goto cleanup;
   }
 
-  hdfsFS userFS = NULL;
-  if (0 == ret) {
-    // if not connected, try to connect and fail out if we can't.
-    if ((userFS = doConnectAsUser(dfs->nn_hostname,dfs->nn_port))== NULL) {
-      ERROR("Could not connect to HDFS");
-      ret = -EIO;
-    }
+  if (hdfsChown(userFS, path, user, group)) {
+    ERROR("Could not chown %s to %d:%d", path, (int)uid, gid);
+    ret = (errno > 0) ? -errno : -EIO;
+    goto cleanup;
   }
 
-  if (0 == ret) {
-    if (hdfsChown(userFS, path, user, group)) {
-      ERROR("Could not chown %s to %d:%d", path, (int)uid, gid);
-      ret = -EIO;
-    }
+cleanup:
+  if (userFS && doDisconnect(userFS)) {
+    ret = -EIO;
   }
-  if (user) 
+  if (user) {
     free(user);
-  if (group)
+  }
+  if (group) {
     free(group);
-#endif
+  }
+
   return ret;
 
 }
diff --git a/src/contrib/fuse-dfs/src/fuse_impls_getattr.c b/src/contrib/fuse-dfs/src/fuse_impls_getattr.c
index a31960c..b0fbd7e 100644
--- a/src/contrib/fuse-dfs/src/fuse_impls_getattr.c
+++ b/src/contrib/fuse-dfs/src/fuse_impls_getattr.c
@@ -19,39 +19,36 @@
 #include "fuse_dfs.h"
 #include "fuse_impls.h"
 #include "fuse_stat_struct.h"
+#include "fuse_connect.h"
 
 int dfs_getattr(const char *path, struct stat *st)
 {
   TRACE1("getattr", path)
 
-  // retrieve dfs specific data
   dfs_context *dfs = (dfs_context*)fuse_get_context()->private_data;
 
-  // check params and the context var
   assert(dfs);
   assert(path);
   assert(st);
 
-  // if not connected, try to connect and fail out if we can't.
-  if (NULL == dfs->fs && 
-      NULL == (dfs->fs = hdfsConnect(dfs->nn_hostname,dfs->nn_port))) {
+  hdfsFS fs = doConnectAsUser(dfs->nn_hostname,dfs->nn_port);
+  if (NULL == fs) {
     ERROR("Could not connect to %s:%d", dfs->nn_hostname, dfs->nn_port);
     return -EIO;
   }
 
-  // call the dfs API to get the actual information
-  hdfsFileInfo *info = hdfsGetPathInfo(dfs->fs,path);
-
+  int ret = 0;
+  hdfsFileInfo *info = hdfsGetPathInfo(fs,path);
   if (NULL == info) {
-    return -ENOENT;
+    ret = -ENOENT;
+    goto cleanup;
   }
-
   fill_stat_structure(&info[0], st);
 
   // setup hard link info - for a file it is 1 else num entries in a dir + 2 (for . and ..)
   if (info[0].mKind == kObjectKindDirectory) {
     int numEntries = 0;
-    hdfsFileInfo *info = hdfsListDirectory(dfs->fs,path,&numEntries);
+    hdfsFileInfo *info = hdfsListDirectory(fs,path,&numEntries);
 
     if (info) {
       hdfsFreeFileInfo(info,numEntries);
@@ -65,5 +62,10 @@ int dfs_getattr(const char *path, struct stat *st)
   // free the info pointer
   hdfsFreeFileInfo(info,1);
 
-  return 0;
+cleanup:
+  if (doDisconnect(fs)) {
+    ERROR("Could not disconnect from filesystem");
+    ret = -EIO;
+  }
+  return ret;
 }
diff --git a/src/contrib/fuse-dfs/src/fuse_impls_mkdir.c b/src/contrib/fuse-dfs/src/fuse_impls_mkdir.c
index 58b9e07..558557d 100644
--- a/src/contrib/fuse-dfs/src/fuse_impls_mkdir.c
+++ b/src/contrib/fuse-dfs/src/fuse_impls_mkdir.c
@@ -25,10 +25,8 @@ int dfs_mkdir(const char *path, mode_t mode)
 {
   TRACE1("mkdir", path)
 
-  // retrieve dfs specific data
   dfs_context *dfs = (dfs_context*)fuse_get_context()->private_data;
 
-  // check params and the context var
   assert(path);
   assert(dfs);
   assert('/' == *path);
@@ -43,25 +41,29 @@ int dfs_mkdir(const char *path, mode_t mode)
     return -EACCES;
   }
   
-  hdfsFS userFS;
-  // if not connected, try to connect and fail out if we can't.
-  if ((userFS = doConnectAsUser(dfs->nn_hostname,dfs->nn_port))== NULL) {
+  hdfsFS userFS = doConnectAsUser(dfs->nn_hostname, dfs->nn_port);
+  if (userFS == NULL) {
     ERROR("Could not connect");
     return -EIO;
   }
 
   // In theory the create and chmod should be atomic.
 
+  int ret = 0;
   if (hdfsCreateDirectory(userFS, path)) {
     ERROR("HDFS could not create directory %s", path);
-    return -EIO;
+    ret = (errno > 0) ? -errno : -EIO;
+    goto cleanup;
   }
 
-#if PERMS
   if (hdfsChmod(userFS, path, (short)mode)) {
     ERROR("Could not chmod %s to %d", path, (int)mode);
-    return -EIO;
+    ret = (errno > 0) ? -errno : -EIO;
+  }
+
+cleanup:
+  if (doDisconnect(userFS)) {
+    ret = -EIO;
   }
-#endif
-  return 0;
+  return ret;
 }
diff --git a/src/contrib/fuse-dfs/src/fuse_impls_open.c b/src/contrib/fuse-dfs/src/fuse_impls_open.c
index 1def4c4..f7d0ed5 100644
--- a/src/contrib/fuse-dfs/src/fuse_impls_open.c
+++ b/src/contrib/fuse-dfs/src/fuse_impls_open.c
@@ -39,19 +39,20 @@ int dfs_open(const char *path, struct fuse_file_info *fi)
   int flags = (fi->flags & 0x7FFF);
 
   // retrieve dfs specific data
-  dfs_fh *fh = (dfs_fh*)malloc(sizeof (dfs_fh));
+  dfs_fh *fh = (dfs_fh*)calloc(1, sizeof (dfs_fh));
   if (fh == NULL) {
     ERROR("Malloc of new file handle failed");
     return -EIO;
   }
 
-  if ((fh->fs = doConnectAsUser(dfs->nn_hostname,dfs->nn_port)) == NULL) {
+  fh->fs = doConnectAsUser(dfs->nn_hostname, dfs->nn_port);
+  if (fh->fs == NULL) {
     ERROR("Could not connect to dfs");
     return -EIO;
   }
 
   if (flags & O_RDWR) {
-    hdfsFileInfo *info = hdfsGetPathInfo(dfs->fs,path);
+    hdfsFileInfo *info = hdfsGetPathInfo(fh->fs,path);
     if (info == NULL) {
       // File does not exist (maybe?); interpret it as a O_WRONLY
       // If the actual error was something else, we'll get it again when
@@ -73,28 +74,20 @@ int dfs_open(const char *path, struct fuse_file_info *fi)
     return -errno;
   }
 
-  // 
-  // mutex needed for reads/writes
-  //
   pthread_mutex_init(&fh->mutex, NULL);
 
   if (fi->flags & O_WRONLY || fi->flags & O_CREAT) {
-    // write specific initialization
     fh->buf = NULL;
   } else  {
-    // read specific initialization
-
     assert(dfs->rdbuffer_size > 0);
-
-    if (NULL == (fh->buf = (char*)malloc(dfs->rdbuffer_size*sizeof (char)))) {
+    fh->buf = (char*)malloc(dfs->rdbuffer_size * sizeof(char));
+    if (NULL == fh->buf) {
       ERROR("Could not allocate memory for a read for file %s\n", path);
       ret = -EIO;
     }
-
     fh->buffersStartOffset = 0;
     fh->bufferSize = 0;
   }
-
   fi->fh = (uint64_t)fh;
 
   return ret;
diff --git a/src/contrib/fuse-dfs/src/fuse_impls_readdir.c b/src/contrib/fuse-dfs/src/fuse_impls_readdir.c
index b0fb1f5..c8d1c0b 100644
--- a/src/contrib/fuse-dfs/src/fuse_impls_readdir.c
+++ b/src/contrib/fuse-dfs/src/fuse_impls_readdir.c
@@ -24,24 +24,15 @@
 int dfs_readdir(const char *path, void *buf, fuse_fill_dir_t filler,
                        off_t offset, struct fuse_file_info *fi)
 {
-  TRACE1("readdir",path)
-
-  (void) offset;
-  (void) fi;
-
-  // retrieve dfs specific data
+  TRACE1("readdir", path)
   dfs_context *dfs = (dfs_context*)fuse_get_context()->private_data;
 
-  // check params and the context var
   assert(dfs);
   assert(path);
   assert(buf);
 
-  int path_len = strlen(path);
-
-  hdfsFS userFS;
-  // if not connected, try to connect and fail out if we can't.
-  if ((userFS = doConnectAsUser(dfs->nn_hostname,dfs->nn_port))== NULL) {
+  hdfsFS userFS = doConnectAsUser(dfs->nn_hostname, dfs->nn_port);
+  if (userFS == NULL) {
     ERROR("Could not connect");
     return -EIO;
   }
@@ -50,16 +41,16 @@ int dfs_readdir(const char *path, void *buf, fuse_fill_dir_t filler,
   // component (HDFS-975) would save us from parsing it out below.
   int numEntries = 0;
   hdfsFileInfo *info = hdfsListDirectory(userFS, path, &numEntries);
-  userFS = NULL;
 
+  int ret = 0;
   // NULL means either the directory doesn't exist or maybe IO error.
   if (NULL == info) {
-    return -ENOENT;
+    ret = (errno > 0) ? -errno : -ENOENT;
+    goto cleanup;
   }
 
   int i ;
   for (i = 0; i < numEntries; i++) {
-
     if (NULL == info[i].mName) {
       ERROR("Path %s info[%d].mName is NULL", path, i);
       continue;
@@ -115,5 +106,11 @@ int dfs_readdir(const char *path, void *buf, fuse_fill_dir_t filler,
     }
   // free the info pointers
   hdfsFreeFileInfo(info,numEntries);
-  return 0;
+
+cleanup:
+  if (doDisconnect(userFS)) {
+    ret = -EIO;
+    ERROR("Failed to disconnect %d", errno);
+  }
+  return ret;
 }
diff --git a/src/contrib/fuse-dfs/src/fuse_impls_release.c b/src/contrib/fuse-dfs/src/fuse_impls_release.c
index d19fc8d..78ea2b1 100644
--- a/src/contrib/fuse-dfs/src/fuse_impls_release.c
+++ b/src/contrib/fuse-dfs/src/fuse_impls_release.c
@@ -19,6 +19,7 @@
 #include "fuse_dfs.h"
 #include "fuse_impls.h"
 #include "fuse_file_handle.h"
+#include "fuse_connect.h"
 
 /**
  * This mutex is to protect releasing a file handle in case the user calls close in different threads
@@ -63,6 +64,11 @@ int dfs_release (const char *path, struct fuse_file_info *fi) {
     if (fh->buf != NULL) {
       free(fh->buf);
     }
+
+    if (doDisconnect(fh->fs)) {
+      ret = -EIO;
+    }
+
     // this is always created and initialized, so always destroy it. (see dfs_open)
     pthread_mutex_destroy(&fh->mutex);
 
diff --git a/src/contrib/fuse-dfs/src/fuse_impls_rename.c b/src/contrib/fuse-dfs/src/fuse_impls_rename.c
index 25a3324..96ac082 100644
--- a/src/contrib/fuse-dfs/src/fuse_impls_rename.c
+++ b/src/contrib/fuse-dfs/src/fuse_impls_rename.c
@@ -46,17 +46,23 @@ int dfs_rename(const char *from, const char *to)
     return -EACCES;
   }
 
-  hdfsFS userFS;
-  // if not connected, try to connect and fail out if we can't.
-  if ((userFS = doConnectAsUser(dfs->nn_hostname,dfs->nn_port))== NULL) {
+  hdfsFS userFS = doConnectAsUser(dfs->nn_hostname, dfs->nn_port);
+  if (userFS == NULL) {
     ERROR("Could not connect");
     return -EIO;
   }
 
+  int ret = 0;
   if (hdfsRename(userFS, from, to)) {
     ERROR("Rename %s to %s failed", from, to);
-    return -EIO;
+    ret = (errno > 0) ? -errno : -EIO;
+    goto cleanup;
+  }
+
+cleanup:
+  if (doDisconnect(userFS)) {
+    ret = -EIO;
   }
+  return ret;
 
-  return 0;
 }
diff --git a/src/contrib/fuse-dfs/src/fuse_impls_rmdir.c b/src/contrib/fuse-dfs/src/fuse_impls_rmdir.c
index b17d892..57127ce 100644
--- a/src/contrib/fuse-dfs/src/fuse_impls_rmdir.c
+++ b/src/contrib/fuse-dfs/src/fuse_impls_rmdir.c
@@ -27,10 +27,8 @@ int dfs_rmdir(const char *path)
 {
   TRACE1("rmdir", path)
 
-  // retrieve dfs specific data
   dfs_context *dfs = (dfs_context*)fuse_get_context()->private_data;
 
-  // check params and the context var
   assert(path);
   assert(dfs);
   assert('/' == *path);
@@ -45,27 +43,34 @@ int dfs_rmdir(const char *path)
     return -EACCES;
   }
 
-  hdfsFS userFS;
-  // if not connected, try to connect and fail out if we can't.
-  if ((userFS = doConnectAsUser(dfs->nn_hostname,dfs->nn_port))== NULL) {
+  hdfsFS userFS = doConnectAsUser(dfs->nn_hostname, dfs->nn_port);
+  if (userFS == NULL) {
     ERROR("Could not connect");
     return -EIO;
   }
 
+  int ret = 0;
   int numEntries = 0;
   hdfsFileInfo *info = hdfsListDirectory(userFS,path,&numEntries);
 
-  // free the info pointers
-  hdfsFreeFileInfo(info,numEntries);
+  if (info) {
+    hdfsFreeFileInfo(info, numEntries);
+  }
 
   if (numEntries) {
-    return -ENOTEMPTY;
+    ret = -ENOTEMPTY;
+    goto cleanup;
   }
 
   if (hdfsDeleteWithTrash(userFS, path, dfs->usetrash)) {
     ERROR("Error trying to delete directory %s", path);
-    return -EIO;
+    ret = -EIO;
+    goto cleanup;
   }
 
-  return 0;
+cleanup:
+  if (doDisconnect(userFS)) {
+    ret = -EIO;
+  }
+  return ret;
 }
diff --git a/src/contrib/fuse-dfs/src/fuse_impls_statfs.c b/src/contrib/fuse-dfs/src/fuse_impls_statfs.c
index 9185cda..476ffe3 100644
--- a/src/contrib/fuse-dfs/src/fuse_impls_statfs.c
+++ b/src/contrib/fuse-dfs/src/fuse_impls_statfs.c
@@ -25,20 +25,16 @@ int dfs_statfs(const char *path, struct statvfs *st)
 {
   TRACE1("statfs",path)
 
-  // retrieve dfs specific data
   dfs_context *dfs = (dfs_context*)fuse_get_context()->private_data;
 
-  // check params and the context var
   assert(path);
   assert(st);
   assert(dfs);
 
-  // init the stat structure
   memset(st,0,sizeof(struct statvfs));
 
-  hdfsFS userFS;
-  // if not connected, try to connect and fail out if we can't.
-  if ((userFS = doConnectAsUser(dfs->nn_hostname,dfs->nn_port))== NULL) {
+  hdfsFS userFS = doConnectAsUser(dfs->nn_hostname, dfs->nn_port);
+  if (userFS == NULL) {
     ERROR("Could not connect");
     return -EIO;
   }
@@ -47,32 +43,15 @@ int dfs_statfs(const char *path, struct statvfs *st)
   const tOffset used  = hdfsGetUsed(userFS);
   const tOffset bsize = hdfsGetDefaultBlockSize(userFS);
 
-  // fill in the statvfs structure
-
-  /* FOR REFERENCE:
-     struct statvfs {
-     unsigned long  f_bsize;    // file system block size
-     unsigned long  f_frsize;   // fragment size
-     fsblkcnt_t     f_blocks;   // size of fs in f_frsize units
-     fsblkcnt_t     f_bfree;    // # free blocks
-     fsblkcnt_t     f_bavail;   // # free blocks for non-root
-     fsfilcnt_t     f_files;    // # inodes
-     fsfilcnt_t     f_ffree;    // # free inodes
-     fsfilcnt_t     f_favail;   // # free inodes for non-root
-     unsigned long  f_fsid;     // file system id
-     unsigned long  f_flag;     / mount flags
-     unsigned long  f_namemax;  // maximum filename length
-     };
-  */
+  if (doDisconnect(userFS)) {
+    return -EIO;
+  }
 
   st->f_bsize   =  bsize;
   st->f_frsize  =  bsize;
-
   st->f_blocks  =  cap/bsize;
-
   st->f_bfree   =  (cap-used)/bsize;
   st->f_bavail  =  (cap-used)/bsize;
-
   st->f_files   =  1000;
   st->f_ffree   =  500;
   st->f_favail  =  500;
@@ -82,4 +61,3 @@ int dfs_statfs(const char *path, struct statvfs *st)
 
   return 0;
 }
-
diff --git a/src/contrib/fuse-dfs/src/fuse_impls_truncate.c b/src/contrib/fuse-dfs/src/fuse_impls_truncate.c
index cf2b0e4..819565e 100644
--- a/src/contrib/fuse-dfs/src/fuse_impls_truncate.c
+++ b/src/contrib/fuse-dfs/src/fuse_impls_truncate.c
@@ -47,11 +47,11 @@ int dfs_truncate(const char *path, off_t size)
     return ret;
   }
 
-  hdfsFS userFS;
-  // if not connected, try to connect and fail out if we can't.
-  if ((userFS = doConnectAsUser(dfs->nn_hostname,dfs->nn_port)) == NULL) {
+  hdfsFS userFS = doConnectAsUser(dfs->nn_hostname, dfs->nn_port);
+  if (userFS == NULL) {
     ERROR("Could not connect");
-    return -EIO;
+    ret = -EIO;
+    goto cleanup;
   }
 
   int flags = O_WRONLY | O_CREAT;
@@ -59,12 +59,19 @@ int dfs_truncate(const char *path, off_t size)
   hdfsFile file;
   if ((file = (hdfsFile)hdfsOpenFile(userFS, path, flags,  0, 0, 0)) == NULL) {
     ERROR("Could not connect open file %s", path);
-    return -EIO;
+    ret = -EIO;
+    goto cleanup;
   }
 
   if (hdfsCloseFile(userFS, file) != 0) {
     ERROR("Could not close file %s", path);
-    return -EIO;
+    ret = -EIO;
+    goto cleanup;
   }
-  return 0;
+
+cleanup:
+  if (doDisconnect(userFS)) {
+    ret = -EIO;
+  }
+  return ret;
 }
diff --git a/src/contrib/fuse-dfs/src/fuse_impls_unlink.c b/src/contrib/fuse-dfs/src/fuse_impls_unlink.c
index ad7872f..54058b4 100644
--- a/src/contrib/fuse-dfs/src/fuse_impls_unlink.c
+++ b/src/contrib/fuse-dfs/src/fuse_impls_unlink.c
@@ -26,16 +26,15 @@ int dfs_unlink(const char *path)
 {
   TRACE1("unlink", path)
 
-  // retrieve dfs specific data
+  int ret = 0;
   dfs_context *dfs = (dfs_context*)fuse_get_context()->private_data;
 
-  // check params and the context var
   assert(path);
   assert(dfs);
   assert('/' == *path);
 
   if (is_protected(path)) {
-    ERROR("Trying to delete protected directory %s ", path);
+    ERROR("Trying to delete protected directory %s", path);
     return -EACCES;
   }
 
@@ -44,17 +43,22 @@ int dfs_unlink(const char *path)
     return -EACCES;
   }
 
-  hdfsFS userFS;
-  // if not connected, try to connect and fail out if we can't.
-  if ((userFS = doConnectAsUser(dfs->nn_hostname,dfs->nn_port))== NULL) {
+  hdfsFS userFS = doConnectAsUser(dfs->nn_hostname, dfs->nn_port);
+  if (userFS == NULL) {
     ERROR("Could not connect");
     return -EIO;
   }
 
   if (hdfsDeleteWithTrash(userFS, path, dfs->usetrash)) {
     ERROR("Could not delete file %s", path);
-    return -EIO;
+    ret = (errno > 0) ? -errno : -EIO;
+    goto cleanup;
+  }
+
+cleanup:
+  if (doDisconnect(userFS)) {
+    ret = -EIO;
   }
+  return ret;
 
-  return 0;
 }
diff --git a/src/contrib/fuse-dfs/src/fuse_impls_utimens.c b/src/contrib/fuse-dfs/src/fuse_impls_utimens.c
index 069d27a..24df6b8 100644
--- a/src/contrib/fuse-dfs/src/fuse_impls_utimens.c
+++ b/src/contrib/fuse-dfs/src/fuse_impls_utimens.c
@@ -23,11 +23,9 @@
 int dfs_utimens(const char *path, const struct timespec ts[2])
 {
   TRACE1("utimens", path)
-#if PERMS
-  // retrieve dfs specific data
+  int ret = 0;
   dfs_context *dfs = (dfs_context*)fuse_get_context()->private_data;
 
-  // check params and the context var
   assert(path);
   assert(dfs);
   assert('/' == *path);
@@ -35,25 +33,31 @@ int dfs_utimens(const char *path, const struct timespec ts[2])
   time_t aTime = ts[0].tv_sec;
   time_t mTime = ts[1].tv_sec;
 
-  hdfsFS userFS;
-  // if not connected, try to connect and fail out if we can't.
-  if ((userFS = doConnectAsUser(dfs->nn_hostname,dfs->nn_port))== NULL) {
+  hdfsFS userFS = doConnectAsUser(dfs->nn_hostname, dfs->nn_port);
+  if (userFS == NULL) {
     ERROR("Could not connect");
     return -EIO;
   }
 
   if (hdfsUtime(userFS, path, mTime, aTime)) {
-    hdfsFileInfo *info = hdfsGetPathInfo(dfs->fs,path);
+    hdfsFileInfo *info = hdfsGetPathInfo(userFS, path);
     if (info == NULL) {
-      return -EIO;
+      ret = (errno > 0) ? -errno : -ENOENT;
+      goto cleanup;
     }
     // Silently ignore utimens failure for directories, otherwise 
     // some programs like tar will fail.
     if (info->mKind == kObjectKindDirectory) {
-      return 0;
+      ret = 0;
+    } else {
+      ret = (errno > 0) ? -errno : -EACCES;
     }
-    return -errno;
+    goto cleanup;
   }
-#endif  
-  return 0;
+
+cleanup:
+  if (doDisconnect(userFS)) {
+    ret = -EIO;
+  }
+  return ret;
 }
diff --git a/src/contrib/fuse-dfs/src/fuse_init.c b/src/contrib/fuse-dfs/src/fuse_init.c
index f492a3f..22c7767 100644
--- a/src/contrib/fuse-dfs/src/fuse_init.c
+++ b/src/contrib/fuse-dfs/src/fuse_init.c
@@ -22,6 +22,7 @@
 #include "fuse_init.h"
 #include "fuse_options.h"
 #include "fuse_context_handle.h"
+#include "fuse_connect.h"
 
 // Hacked up function to basically do:
 //  protectedpaths = split(options.protected,':');
@@ -30,7 +31,6 @@ void init_protectedpaths(dfs_context *dfs) {
 
   char *tmp = options.protected;
 
-
   // handle degenerate case up front.
   if (tmp == NULL || 0 == *tmp) {
     dfs->protectedpaths = (char**)malloc(sizeof(char*));
@@ -43,7 +43,6 @@ void init_protectedpaths(dfs_context *dfs) {
     print_options();
   }
 
-
   int i = 0;
   while (tmp && (NULL != (tmp = index(tmp,':')))) {
     tmp++; // pass the ,
@@ -75,27 +74,15 @@ void init_protectedpaths(dfs_context *dfs) {
     j++;
   }
   dfs->protectedpaths[j] = NULL;
-
-  /*
-    j  = 0;
-    while (dfs->protectedpaths[j]) {
-    printf("dfs->protectedpaths[%d]=%s\n",j,dfs->protectedpaths[j]);
-    fflush(stdout);
-    j++;
-    }
-    exit(1);
-  */
 }
 
-void *dfs_init()
-{
 
+void *dfs_init(void) {
   //
   // Create a private struct of data we will pass to fuse here and which
   // will then be accessible on every call.
   //
-  dfs_context *dfs = (dfs_context*)malloc(sizeof (dfs_context));
-
+  dfs_context *dfs = (dfs_context*)malloc(sizeof(dfs_context));
   if (NULL == dfs) {
     ERROR("FATAL: could not malloc dfs_context");
     exit(1);
@@ -105,7 +92,6 @@ void *dfs_init()
   dfs->debug                 = options.debug;
   dfs->nn_hostname           = options.server;
   dfs->nn_port               = options.port;
-  dfs->fs                    = NULL;
   dfs->read_only             = options.read_only;
   dfs->usetrash              = options.usetrash;
   dfs->protectedpaths        = NULL;
@@ -121,14 +107,17 @@ void *dfs_init()
     DEBUG("dfs->rdbuffersize <= 0 = %ld", dfs->rdbuffer_size);
     dfs->rdbuffer_size = 32768;
   }
+
+  if (0 != allocFsTable()) {
+    ERROR("FATAL: could not allocate ");
+    exit(1);
+  }
+
   return (void*)dfs;
 }
 
 
-
-void dfs_destroy (void *ptr)
+void dfs_destroy(void *ptr)
 {
   TRACE("destroy")
-  dfs_context *dfs = (dfs_context*)ptr;
-  dfs->fs = NULL;
 }
diff --git a/src/contrib/fuse-dfs/src/fuse_options.c b/src/contrib/fuse-dfs/src/fuse_options.c
index c880a8c..4264f01 100644
--- a/src/contrib/fuse-dfs/src/fuse_options.c
+++ b/src/contrib/fuse-dfs/src/fuse_options.c
@@ -107,10 +107,10 @@ int dfs_options(void *data, const char *arg, int key,  struct fuse_args *outargs
 
   switch (key) {
   case FUSE_OPT_KEY_OPT:
-    fprintf(stderr, "fuse-dfs ignoring option %s\n", arg);
+    INFO("Ignoring option %s", arg);
     return 1;
-  case  KEY_VERSION:
-    fprintf(stdout, "%s %s\n", program, _FUSE_DFS_VERSION);
+  case KEY_VERSION:
+    INFO("%s %s\n", program, _FUSE_DFS_VERSION);
     exit(0);
   case KEY_HELP:
     print_usage(program);
@@ -159,14 +159,13 @@ int dfs_options(void *data, const char *arg, int key,  struct fuse_args *outargs
       } else if (strcmp(arg,"rw") == 0) {
         options.read_only = 0;
       } else {
-        ERROR("fuse-dfs didn't recognize %s,%d\n",arg,key);
-        fuse_opt_add_arg(outargs,arg);
+        INFO("Adding FUSE arg %s", arg);
+        fuse_opt_add_arg(outargs, arg);
         return 0;
       }
     } else {
       options.port = tmp_port;
       options.server = strdup(tmp_server);
-      ERROR("port=%d,server=%s\n", options.port, options.server);
     }
   }
   }
diff --git a/src/contrib/fuse-dfs/src/fuse_stat_struct.c b/src/contrib/fuse-dfs/src/fuse_stat_struct.c
index c880fab..e3a0725 100644
--- a/src/contrib/fuse-dfs/src/fuse_stat_struct.c
+++ b/src/contrib/fuse-dfs/src/fuse_stat_struct.c
@@ -25,18 +25,15 @@
 #include "fuse_stat_struct.h"
 #include "fuse_context_handle.h"
 
-#if PERMS
-/**
+/*
  * getpwuid and getgrgid return static structs so we safeguard the contents
  * while retrieving fields using the 2 structs below.
  * NOTE: if using both, always get the passwd struct firt!
  */
 extern pthread_mutex_t passwdstruct_mutex; 
 extern pthread_mutex_t groupstruct_mutex;
-#endif
-
 
-const int default_id       = 99; // nobody  - not configurable since soon uids in dfs, yeah!
+const int default_id = 99; // nobody  - not configurable since soon uids in dfs, yeah!
 const int blksize = 512;
 
 /**
@@ -55,7 +52,6 @@ int fill_stat_structure(hdfsFileInfo *info, struct stat *st)
   st->st_nlink = (info->mKind == kObjectKindDirectory) ? 0 : 1;
 
   uid_t owner_id = default_id;
-#if PERMS
   if (info->mOwner != NULL) {
     //
     // Critical section - protect from concurrent calls in different threads since
@@ -73,9 +69,9 @@ int fill_stat_structure(hdfsFileInfo *info, struct stat *st)
     pthread_mutex_unlock(&passwdstruct_mutex);
 
   } 
-#endif
+
   gid_t group_id = default_id;
-#if PERMS
+
   if (info->mGroup != NULL) {
     //
     // Critical section - protect from concurrent calls in different threads since
@@ -93,15 +89,12 @@ int fill_stat_structure(hdfsFileInfo *info, struct stat *st)
     pthread_mutex_unlock(&groupstruct_mutex);
 
   }
-#endif
 
   short perm = (info->mKind == kObjectKindDirectory) ? (S_IFDIR | 0777) :  (S_IFREG | 0666);
-#if PERMS
   if (info->mPermissions > 0) {
     perm = (info->mKind == kObjectKindDirectory) ? S_IFDIR:  S_IFREG ;
     perm |= info->mPermissions;
   }
-#endif
 
   // set stat metadata
   st->st_size     = (info->mKind == kObjectKindDirectory) ? 4096 : info->mSize;
@@ -110,11 +103,7 @@ int fill_stat_structure(hdfsFileInfo *info, struct stat *st)
   st->st_mode     = perm;
   st->st_uid      = owner_id;
   st->st_gid      = group_id;
-#if PERMS
   st->st_atime    = info->mLastAccess;
-#else
-  st->st_atime    = info->mLastMod;
-#endif
   st->st_mtime    = info->mLastMod;
   st->st_ctime    = info->mLastMod;
 
diff --git a/src/contrib/fuse-dfs/src/fuse_users.c b/src/contrib/fuse-dfs/src/fuse_users.c
index 4637a28..d7bdfe7 100644
--- a/src/contrib/fuse-dfs/src/fuse_users.c
+++ b/src/contrib/fuse-dfs/src/fuse_users.c
@@ -24,26 +24,19 @@
 
 #include "fuse_dfs.h"
 
-
-
-#if PERMS
-/**
+/*
  * getpwuid and getgrgid return static structs so we safeguard the contents
  * while retrieving fields using the 2 structs below.
  * NOTE: if using both, always get the passwd struct firt!
  */
 pthread_mutex_t passwdstruct_mutex = PTHREAD_MUTEX_INITIALIZER;
 pthread_mutex_t groupstruct_mutex = PTHREAD_MUTEX_INITIALIZER;
-#endif
 
-#if PERMS
-
-/**
+/*
  * Utility for getting the user making the fuse call in char * form
  * NOTE: if non-null return, the return must be freed by the caller.
  */
-char *getUsername(uid_t uid)
-{
+char *getUsername(uid_t uid) {
   //
   // Critical section - protect from concurrent calls in different threads.
   // since the struct below is static.
@@ -218,4 +211,3 @@ char ** getGroups(uid_t uid, int *num_groups)
 #endif
   return groupnames;
 }
-#endif
-- 
1.7.0.4

